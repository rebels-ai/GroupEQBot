Situation:

    2 types of output: 
        - events (manageable by interface) comes from group chats
        - validation events comes from ConversationHandler (private user:bot chats)
    We need interface for storing those events and reading them

    group chats
        users --> events
              --> validation events * adjust interface to skip them

    bot chats
        users --> validation events
              --> events * adjust interface to skip them

Tasks:

    * get one user's event from one group chat
    * get many user's event from one group chat

    * get one user's event from many group chats
    * get many user's event from many group chats

    * get one user's event from bot chat
    * get many user's event from bot chats


# Indeces

### ChatsNameIDMappings
```
Description: ...
```



### GroupUsers
```
Description:
    Multiple Indeces containing list of users for according group and their metadata including validation info

GroupUsers
    [
        userID: (userID generated by Telegram)
            status:
                {
                    currnet_status: str
                    change_history_status: {status: timestamp, status: timestamp}
                }

            metadata:
                {
                    change_history_firstname: {firstname: timestamp, firstname: timestamp}
                    change_history_lastname: {lastname: timestamp, lastname: timestamp}
                    change_history_username: {username: timestamp, username: timestamp}
                }

            validation:
                {
                    passed: bool          (by default False)
                    start_time: timestamp (by default None)
                    end_time: timestamp   (by default None)
                }
            
            statistics:
                {
                    ...  # to think
                }
    ]


```

### GroupEvents
```
Description:
    Multiple Indeces for storing events for particular group chat

GroupEvents
    [
        eventID:  (eventID generated by Database)
            {
                userID: int
                message_id: int  (MessageID from telegram, None if MemberUpdate)
                eventTime: timestamp
                eventType: str (MemberEvent; MessageEvent (Audio ...))
                content: str | None 
                        (none because currently we support just text messages. if not text message, refere to contentMetadata)
                contentMetadata:
                    {
                        ...
                    }
                raw: ExpectedInternalEvent (for any sort of additional anaylysis)
            }
    ]
```

### BotMetadata
```
Description:
    Single Index for storing bot metadata information per group

BotMetadata
    [
        chatID: (chatID generated by Telegram)
            {
                chat_owner: str
                chat_name: str
                chat_type: str
                bot_add_time: timestamp
                bot_status: str
            }
    ]
```


### BotEvents
```
Description:
    Single Index for storing validation events for users from groups, where both user and bot are presented 

BotEvents
    [
        chatID: (chatID generated by Telegram)
            [
                userID: (userID generated by Telegram)
                    [
                        eventID:  (eventID generated by Database)
                            {
                                message_id: int  (MessageID from telegram, None if MemberUpdate)
                                eventTime: timestamp
                                content: str | None 
                                        (none because currently we support just text messages. if not text message, refere to contentMetadata)
                                contentMetadata:
                                    {
                                        ...
                                    }
                                raw: ExpectedInternalEvent (for any sort of additional anaylysis)
                            }
                    ]
            ]
    ]
```

# Conceptual Solution for `GroupEvents` & `GroupUsers`

`Situation:`
There is group with certain amount of users. We would like to add bot to the group. (bot will have admin rights at that moment)

- Bot has to start registirng all the events and write those DB in `GroupEvents` Index.
- Bot gets the list of all the memberes in the group and write those in DB in `GroupUsers` Index
- Bot has to create entity in `BotMetadata` Index within the group information (PP)


```
telegram --> update (MyChatMember Update) --> router --> PublicEventProcessor --> 
    if self.internal_event.event_type == EventType.bot:  # bot was added into the group
        BackgroundUsersInitializer()  # Bot gets the list of all the memberes ...
        BackgroundBotMetadataInitializer()  # Bot has to create entity in `BotMetadata` ...
```









# Next 
* find get_chat_member
* does get_chat_members works for bots?


Functionality to glue indeces 
User can start validation if following are True:

    - Bot and user are in the same group chat (Implement BotMetaData Index)
        Questions:
            How to check in which groups bot is added and is admin?
            How to get list of all group members?
                We plan to use UserIndex
                Or bot methods if allowed
        Potential use cases:
        - User joined after bot was added to the group
        - User joined before the bot was added to the group

    - User hadn't started the validation
        Questions:
            How to check that user did not start the validation?
                We plan to use UserIndex





________________________

What we need to save:
    - all incoming events
        - public chat
        - private bot:user chats (validation)
    - user info
        - chat ids
        - user metrics
        - validation passed
        - validation answers
    - chat info
        - members list
        - members who passed validation

Indeces:
    - Validation index (bot:user private chat)


1. Carry over button logic to it's dedicated place (check components folder)
2. Re-iterate member statuses logic
3. Add logic for /start button
4. Update storage.interface docstrings



ConversationHandler
    - manage situation, when in a particular group VALIDATED member is attempting to pass the validation
    ** check new index for bot (validating process)

    ** if member passed

    - manage situation when user blocked --> going to priv chat with bot and passes the validation

    - manage creating new index for bot (validating process)
        ** add conversation (validation) history
        ** should be single (static) index
            - user id
            - chat id (where user is trying to pass validation)
            - user + user start validation time + user end validation time + user cancel validation time
            ...

    - manage situation, when in a particular group VALIDATED member is attempting to pass the validation
    ** check new index for bot (validating process)

    ** if member passed

    - manage situation when user blocked --> going to priv chat with bot and passes the validation

    - manage creating new index for bot (validating process)
        ** add conversation (validation) history
        ** should be single (static) index
            - user id
            - chat id (where user is trying to pass validation)
            - user + user start validation time + user end validation time + user cancel validation time
            ...


_____________________


## SYSTEM GENERAL FLOW

Public events - group chats with bot

Case 1: Bot was added to the group

event: bot was added
action: register event in DB in BotMetadata index, status 'member'

Case 2: Bot status was changed to admin

event: bot was added to admins
action1: find previous bot event for this chat in DB in BotMetadata index, update status to 'admin'
--->
action2: fetch existing members, register them in DB in GroupUsers index

Case 3: 

event: bot was deleted from the group
action: find previous bot event for this chat in DB in BotMetadata index, update status to 'left'
    *mb add field 'active/inactive'

Case 4:

event: old_status - admin, new_status - member
action: find previous bot event for this chat in DB in BotMetadata index, update status to 'member'

## Validation flow

if bot and user are presented in the same chat --> save all events
Case 0:

event: user started bot

        if `context.user_data['chat_id']` is not empty
            and bot and user are presented in the same chat --> save all events
            and validation.passed == False
        send user instruction for validation
        save to BotEvent index

        else:
            
@TODO: action on bot_member update for private chat

Case 1:

event: user started validation via cmd
action: in start_validation cmd callback --> find doc in GroupUsers by user_id, index name includes `context.user_data['chat_id']` 
--> if `validation.passed` == True:
        --> send message to user
            stop validation
    else:
        --> change field "start_date" 
            continue validation

* index_name = Configurator.bot_varsion + group-users + chat_id

Case 2:

event: user answers the question and still have attemps left
action: create index BotEvent if not exist -> create doc in BotEvent if not exist (per chat) -> update doc for this chat for this user

Case 3:

event: user failed validation
action: find doc in GroupUsers --> change field "end_date"
action2: update doc in BotEvent

Case 4:

event: user passed validation
action: find doc in GroupUsers --> change field "end_date" ans "passed"
action2: update doc in BotEvent

Case 6:

event: user canceled validation
action: ???


## Validation flow vers.2

new user joins the chat --> register member_update --> create doc in GroupUsers index for chat_id

new user starts the bot --> register bot_private_update -->
--> search query in all GroupUsers indeces 
    with fields "user_id"
    response = user_id, chat_id, validation.passed

if user not found:
    send message "u r not found in my chats. Or you were added after I started work in your group.
                    If you want to use GroupEQBot add me to your group chat and give me admin rights"

    *** Search how to stop user from sending cmds or messages to bot ***
    or methods to restrict sending command (/start_validation)

elif user found:
    user_not_passed = []
    for chat in chats where user is presented:
        if validation.passed == False:
            user_not_passed.append(chat_id)

    if len(user_not_passed) == 0:
        send message "validation already passed"

        *** Search how to stop user from sending cmds or messages to bot ***
        or methods to restrict sending command (/start_validation)


    else:
        query ChatsMappings using "chat_id"
        response = {chat_id: chat_name, ...}

        if len(response)==1:
            single button
        else:
            many buttons

            make button(callback=chat_id, text=chat_name)
            keyboard.append(button)

        button will be the entry_point of ConversationHandler

_____________________
# Bot behaviour use cases in terms of interactions with database


### Adding Bot into Group (supergroup) (bot does not has admit rights yet)
 ⁃ Create | Update DB BotMetadata index entity
 ⁃ Create | Update DB ChatNameIDMappings index entity

###  Granting Bot in added Group (supergroup) admin rights
 ⁃ Update bot.status attribute in DB BotMetadata index entity
 ⁃ Fetch all users presented in the group and create each user in GroupUsers index (**WIP) 

### Bot has to register messages events happening in the added group after granting admin rights
 ⁃ Each message event will be created (written) in GroupEvents index

# New member joining the group
 ⁃ Create | Update GroupUsers index entity (create user in DB)
 ⁃ Create GroupEvents index entity (create event about user was written in DB)

 ⁃ Bot restricts rights for the user
 ⁃ Create GroupEvents index entity (create event about user rights was restricted)
 ⁃ Update GroupUsers index entity (update user status changed)
 ⁃ Bot sends welcome message, asking to pass the validation

# New member taps the button in public chat and starts the bot in private chat
 ⁃ Bot sends instructions to the user

# New member taps start_validation command
 ⁃ Read from ALL GroupUsers indeces whether new member ID is presented in index
 ⁃ if user presented
 ⁃ Read chatNames from GroupChatIDMappings by chat_id
 ⁃ bot sends generated buttons with chatNames
 ⁃ Update BotEvents index (create event about clicking the button by user) (** WIP)

—> once member clicked chatName button
  - Update GroupUsers index (updated user.validation.start_time attribute)
 ⁃ <-> new member answers on validation questions
 ⁃ Update BotEvents index (create event about new member answering validation questions) (** WIP)
 ⁃ if passed validation
 ⁃ Update GroupUsers index entity (update user status changed on member)
 ⁃ Update GroupUsers index entity (update user stop validation time)
 ⁃ if failed validation
 ⁃ Update GroupUsers index entity (update user status changed on banned)
 ⁃ Update GroupUsers index entity (update user stop validation time)


Notes:
- add link button to the group if validation passed


*****************************************

Testing plan:

# Bot status updates

### Adding Bot into Supergroup 
 ⁃ Create | Update DB BotMetadata index entity
    - bot.status should be 'member'
 ⁃ Create | Update DB ChatNameIDMappings index entity

### Granting Bot in Supergroup admin rights
 ⁃ Update bot.status attribute in DB BotMetadata index entity
    - bot.status should be 'administrator'

### Demote/delete the bot from supergroup
 ⁃ Update bot.status attribute in DB BotMetadata index entity
    - bot.status should be 'left' | 'member' | 'restricted'


# Bot in supergroup behaviour

### Sending messages | adding members
 ⁃ Create | Update DB GroupEvents index
    - should be separate index dedicated to one chat

### Changing any member statuses 
 ⁃ Create | Update DB GroupEvents index
    - should be separate index dedicated to one chat
    - member previous status should be saved in db
        - change_historical_status: [{old_status: date}]
        - current_status: new_status


# New members in the supergroup

### New member joined
 ⁃ Create | Update GroupUsers index entity (create user in DB)
     - should be separate index dedicated to one chat
 ⁃ Create | Update DB GroupEvents index
 ⁃ Bot restricts user rights - changed to restrict all, bcse they dont need to pass validation in group chat anymore
 ⁃ Bot sends weclome message with link to private chat


# Private chat with bot

### Any user starts the bot in private chat
    - Bot send instruction for validation

### User clicks /start_validation
 ⁃ Read from ALL GroupUsers indeces whether new member ID is presented in index

#### User is not known by bot
    - Bot sends message 'i dont know you'

#### User is known by bot
 ⁃ Read chatNames from GroupChatIDMappings by chat_id
    - user already passed validation
        - bot sends messsage 'you already passed'
    - user did not pass the validation
        ⁃ bot sends generated buttons with chatNames
        ⁃ Create | Update BotEvents index

#### User starts validation with clicking the button
 - Update GroupUsers index (updated user.validation.start_time attribute)
 - Update BotEvents index with this event
 ⁃ Update BotEvents index with any user answers

#### User passed validation
 - Bot sends congrats to user
 - Bot disables restrictions in the group chat
 ⁃ Update GroupUsers index entity (update user status changed on member)
 ⁃ Update GroupUsers index entity (update user stop validation time)
 - Update GroupEvents index with change status event

#### User failed validation
 - Bot banns user in the group chat
 ⁃ Update GroupUsers index entity (update user status changed on banned)
 ⁃ Update GroupUsers index entity (update user stop validation time)
 - Update GroupEvents index with change status event
