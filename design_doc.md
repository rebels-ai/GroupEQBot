Situation:

    2 types of output: 
        - events (manageable by interface) comes from group chats
        - validation events comes from ConversationHandler (private user:bot chats)
    We need interface for storing those events and reading them

    group chats
        users --> events
              --> validation events * adjust interface to skip them

    bot chats
        users --> validation events
              --> events * adjust interface to skip them

Tasks:

    * get one user's event from one group chat
    * get many user's event from one group chat

    * get one user's event from many group chats
    * get many user's event from many group chats

    * get one user's event from bot chat
    * get many user's event from bot chats


# Indeces

### ChatsNameIDMappings
```
Description: ...
```



### GroupUsers
```
Description:
    Multiple Indeces containing list of users for according group and their metadata including validation info

GroupUsers
    [
        userID: (userID generated by Telegram)
            status:
                {
                    currnet_status: str
                    change_history_status: {status: timestamp, status: timestamp}
                }

            metadata:
                {
                    change_history_firstname: {firstname: timestamp, firstname: timestamp}
                    change_history_lastname: {lastname: timestamp, lastname: timestamp}
                    change_history_username: {username: timestamp, username: timestamp}
                }

            validation:
                {
                    passed: bool          (by default False)
                    start_time: timestamp (by default None)
                    end_time: timestamp   (by default None)
                }
            
            statistics:
                {
                    ...  # to think
                }
    ]


```

### GroupEvents
```
Description:
    Multiple Indeces for storing events for particular group chat

GroupEvents
    [
        eventID:  (eventID generated by Database)
            {
                userID: int
                message_id: int  (MessageID from telegram, None if MemberUpdate)
                eventTime: timestamp
                eventType: str (MemberEvent; MessageEvent (Audio ...))
                content: str | None 
                        (none because currently we support just text messages. if not text message, refere to contentMetadata)
                contentMetadata:
                    {
                        ...
                    }
                raw: ExpectedInternalEvent (for any sort of additional anaylysis)
            }
    ]
```

### BotMetadata
```
Description:
    Single Index for storing bot metadata information per group

BotMetadata
    [
        chatID: (chatID generated by Telegram)
            {
                chat_owner: str
                chat_name: str
                chat_type: str
                bot_add_time: timestamp
                bot_status: str
            }
    ]
```


### BotEvents
```
Description:
    Single Index for storing validation events for users from groups, where both user and bot are presented 

BotEvents
    [
        chatID: (chatID generated by Telegram)
            [
                userID: (userID generated by Telegram)
                    [
                        eventID:  (eventID generated by Database)
                            {
                                message_id: int  (MessageID from telegram, None if MemberUpdate)
                                eventTime: timestamp
                                content: str | None 
                                        (none because currently we support just text messages. if not text message, refere to contentMetadata)
                                contentMetadata:
                                    {
                                        ...
                                    }
                                raw: ExpectedInternalEvent (for any sort of additional anaylysis)
                            }
                    ]
            ]
    ]
```

# Conceptual Solution for `GroupEvents` & `GroupUsers`

`Situation:`
There is group with certain amount of users. We would like to add bot to the group. (bot will have admin rights at that moment)

- Bot has to start registirng all the events and write those DB in `GroupEvents` Index.
- Bot gets the list of all the memberes in the group and write those in DB in `GroupUsers` Index
- Bot has to create entity in `BotMetadata` Index within the group information (PP)


```
telegram --> update (MyChatMember Update) --> router --> PublicEventProcessor --> 
    if self.internal_event.event_type == EventType.bot:  # bot was added into the group
        BackgroundUsersInitializer()  # Bot gets the list of all the memberes ...
        BackgroundBotMetadataInitializer()  # Bot has to create entity in `BotMetadata` ...
```









# Next 
* find get_chat_member
* does get_chat_members works for bots?


Functionality to glue indeces 
User can start validation if following are True:

    - Bot and user are in the same group chat (Implement BotMetaData Index)
        Questions:
            How to check in which groups bot is added and is admin?
            How to get list of all group members?
                We plan to use UserIndex
                Or bot methods if allowed
        Potential use cases:
        - User joined after bot was added to the group
        - User joined before the bot was added to the group

    - User hadn't started the validation
        Questions:
            How to check that user did not start the validation?
                We plan to use UserIndex





________________________

What we need to save:
    - all incoming events
        - public chat
        - private bot:user chats (validation)
    - user info
        - chat ids
        - user metrics
        - validation passed
        - validation answers
    - chat info
        - members list
        - members who passed validation

Indeces:
    - Validation index (bot:user private chat)


1. Carry over button logic to it's dedicated place (check components folder)
2. Re-iterate member statuses logic
3. Add logic for /start button
4. Update storage.interface docstrings



ConversationHandler
    - manage situation, when in a particular group VALIDATED member is attempting to pass the validation
    ** check new index for bot (validating process)

    ** if member passed

    - manage situation when user blocked --> going to priv chat with bot and passes the validation

    - manage creating new index for bot (validating process)
        ** add conversation (validation) history
        ** should be single (static) index
            - user id
            - chat id (where user is trying to pass validation)
            - user + user start validation time + user end validation time + user cancel validation time
            ...

    - manage situation, when in a particular group VALIDATED member is attempting to pass the validation
    ** check new index for bot (validating process)

    ** if member passed

    - manage situation when user blocked --> going to priv chat with bot and passes the validation

    - manage creating new index for bot (validating process)
        ** add conversation (validation) history
        ** should be single (static) index
            - user id
            - chat id (where user is trying to pass validation)
            - user + user start validation time + user end validation time + user cancel validation time
            ...
